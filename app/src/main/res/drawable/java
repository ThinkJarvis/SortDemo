20190422
Java语言由8个模块构成，分别为：关键字、标识符（包名、类名、接口名、常量名、变量名等）、注释、常量和变量、运算符、语句、函数、数组。

一、变量的作用域和生存期

变量组成：变量类型，变量名以及变量值


成员变量和局部变量的区别(重点)
1、作用域
成员变量：针对整个类有效。
局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)
2、存储位置
成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。
局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。
当方法调用完，或者语句结束后，就自动释放。
3、初始值
成员变量：有默认初始值。
局部变量：没有默认初始值，使用前必须赋值。

4、匿名对象
(1)匿名对象就是没有名字的对象。是对象的一种简写形式。
(2)应用场景
A:只调用一次类中的方法。
B:可以作为实际参数在方法传递中使用

Java中变量的使用规则：
1、Java 中的变量需要先声明后使用；
2、变量使用时，可以声明变量的同时进行初始化,也可以先声明后赋值；
3、变量中每次只能赋一个值，但可以修改多次；

在Java 中2个主要的作用域是通过类和方法定义的：
1、方法定义的作用域以它的左大括号开始。但是，如果该方法有参数，那么它们也被包括在该方法的作用域中。到右大括号结束
2、作为一个通用规则，在一个作用域中定义的变量对于该作用域外的程序是不可见（即访问）的。因此，当你在一个作用域中定义一个变量时，你就将该变量局部化并且保护它不被非授权访问和/或修改。作用域规则为封装提供了基础。
3、作用域可以进行嵌套。例如每次当你创建一个程序块，你就创建了一个新的嵌套的作用域。这样，外面的作用域包含内部的作用域。这意味着外部作用域定义的对象对于内部作用域中的程序是可见的。但是，反过来就是错误的。内部作用域定义的对象对于外部是不可见的。

Java 局部内部类访问局部变量为什么必须加final关键字？（同样静态内部类不能访问非静态全局变量）
1、生命周期不同： 
因为局部变量直接存储在栈中，当方法执行结束，非final的局部变量就被销毁，而局部内部类对局部变量的引用依然存在。局部内部类要调用局部变量时，就会出错，出现非法引用。简单来说，就是非final的局部变量的生命周期比局部内部类的生命周期短。
2、拷贝造成数据不同步：
内部类并不是直接使用传递进来的参数，而是将传递进来的参数通过自己的构造器备份到自己内部，表面看是同一个变量，实际调用的是自己的属性而不是外部类方法的参数，如果在内部类中，修改了这些参数，并不会对外部变量产生影响，仅仅改变局部内部类中备份的参数。但是在外部调用时发现值并没有被修改，这种问题就会很尴尬，造成数据不同步。
这也是Android静态工具类直接当前页面类的Context会页面被销毁时。造成Context无法释放，从而导致内存泄漏。因为页面销毁时去尝试释放Context时，发现静态工具类还活着，还在持有Context，无法释放。


二、JAVA中分为基本数据类型及引用数据类型

Java中的数据类型分为引用数据类型和基本数据类型。
1、引用数据类型分3种：类，接口，数组；
2、基本数据类型又分布尔类型和数值类型；
3、布尔类型：boolean（逻辑型） true or false默认是false；
4、数值类型分定点类型和浮点类型;
5、定点类型分整数类型和字符型；

2、基本数据类型：
1、boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false
2、byte：Java中最小的数据类型，在内存中占8位(bit)，即1个字节，取值范围（-2的7次方到2的7次方-1），默认值0
3、short：短整型，在内存中占16位，即2个字节，取值范围（-2的15次方到2的15次方-1），默认值0
4、int：整型，用于存储整数，在内在中占32位，即4个字节，取值范围（-2的31次方到2的31次方-1），默认值0
5、long：长整型，在内存中占64位，即8个字节-2^63~2^63-1，默认值0L
6、float：浮点型，在内存中占32位，即4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0
7、double：双精度浮点型，用于存储带有小数点的数字，在内存中占64位，即8个字节，默认值0
8、char：字符型，用于存储单个字符，占16位，即2个字节，取值范围0~65535，默认值为空

Java数据类型在内存中的存储：
1、基本数据类型的存储原理：所有的简单数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的内存栈上的，数据本身的值就是存储在栈空间里面；
2、引用类型的存储原理:引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java内存堆和内存栈来进行这种类型的数据存储，简单地讲，“引用”是存储在有序的内存栈上的，而对象本身的值存储在内存堆上的；

20190423
函数的定义
一、习惯把函数也叫成方法，都是一个意思；函数是具备特定功能的一段代码块，解决了重复性代码的问题，函数是Java中最小的功能单元，函数只有被调用才会执行。

二、函数的参数传递
(1).形式参数：函数定义时的参数为形式参数------>简称形参
(2).实际参数：函数调用时的参数为实际参数 ------>简称实参
参数传递：只能有实参传给形参
注意：实参和形参在个数、顺序、类型上都要保持一致.

三、函数的重载和重写的区别
方法重载是指同一个类中的多个方法具有相同的名字,但这些方法具有不同的参数列表,即参数的数量或参数类型不能完全相同
方法重写是存在子父类之间的,子类定义的方法与父类中的方法具有相同的方法名字,相同的参数表和相同的返回类型  
方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。


20190426
https://blog.csdn.net/u011504806/article/details/80451969

虚拟机栈（JVM Stack）：一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。
堆区（Heap）：堆区是理解Java GC机制最重要的区域，没有之一。在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，堆区由所有线程共享，在虚拟机启动时创建。堆区的存在是为了存储对象实例
方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。

Person p = new Person();在内存中做了哪些事情。
(1)将Person.class文件加载进内存中。
(2)如果p定义在主方法中，那么，就会在栈空间开辟一个变量空间p。
(3)在堆内存给对象分配空间，类中的属性，会跟随对象Phone进入堆内存，则堆内存中的对象有了属性
(4)对对象中的成员进行默认初始化。
(5)对对象中的成员进行显示初始化。
(6)调用构造代码块对对象进行初始化。(如果没有就不执行)
(7)调用构造方法对对象进行初始化。对象初始化完毕。
(8)将对象的内存地址赋值给p变量，让p变量指向该对象。


20190427
https://www.cnblogs.com/skywang12345/p/java_threads_category.html
线程共包括以下5种状态
1、新建状态(New): 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。
2、就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。
3、运行状态(Running) : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。
4、阻塞状态(Blocked) : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
    (01) 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。
    (02) 同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。
    (03) 其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
5、死亡状态(Dead)    	: 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
Object类，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。
Thread类，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。
synchronized，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。

Thread和Runnable的异同点：
1、Thread 和 Runnable 的相同点：都是“多线程的实现方式”。
2、Thread 和 Runnable 的不同点：
	（1）Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。
	（2）此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。


synchronized原理
在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。当我们调用某对象的synchronized方法时，就获取了该对象的同步锁，不同线程对同步锁的访问是互斥的。
同步锁的原理是，对于每一个对象，有且仅有一个同步锁；不同的线程能共同访问该同步锁。但是，在同一个时间点，该同步锁能且只能被一个线程获取到。这样，获取到同步锁的线程就能进行CPU调度，从而在CPU上执行；而没有获取到同步锁的线程，必须进行等待，直到获取到同步锁之后才能继续运行。这就是，多线程通过同步锁进行同步的原理！

synchronized基本规则
1、当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。
2、当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。
3、当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。


实例锁 -- 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。
               实例锁对应的就是synchronized关键字。
全局锁 -- 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。
               全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。
public synchronized void isSyncA()            对象锁
public static synchronized void cSyncA()      类锁


wait(), notify(), notifyAll()等方法介绍
在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。

Object类中关于等待/唤醒的API详细信息如下：
notify()      -- 唤醒在此对象监视器上等待的单个线程。
notifyAll()   -- 唤醒在此对象监视器上等待的所有线程。
wait()        -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。
wait(long timeout)    -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。
wait(long timeout, int nanos)  -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。


yield()介绍
yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！

yield() 与 wait()的比较
我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是：
(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。
(02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。

interrupt()说明
终止处于“阻塞状态”的线程：
我们通过“中断”方式终止处于“阻塞状态”的线程。
当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的为止就能终止线程
终止处于“运行状态”的线程：


20190430
JUC原子操作类
这些类存在的目的是对相应的数据进行原子操作。所谓原子操作，是指操作过程不会被中断，保证数据操作是以原子方式进行的。



RxJava
（1）create     先将投入的发布者对象封装成ObserableCreate对象
（2）subcribeOn 接着把ObserableCreate对象装饰成ObserableSubscribeOn对象
（3）observerOn 最后把ObserableSubscribeOn对象装饰成ObserableObserverOn对象
（4）subcribe   全局对象ObserableSubscribeOn调用subscirbe方法，先调用ObserableObserverOn.onSubscribe方法。下游被绑定了，线程切换到订阅者线程。
（5）           全局对象ObserableCreate调用subscirbe方法，先调用SubscribeOnObserver.onSubscribe方法.然后上游被绑定。
（6）onNext     CreateEmitter.onNext() -> SubscribeOnObserver.onNext() -> ObserveOnObserver.onNext()-> schedule()线程切换到观察者线程 -> drainNormal() -> downStream.onNext
			
线程调度实现以IOScheduler为例
scheduleDirect先创建一个线程工人，ThreadWorker，会执行scheduleDirect，会去调用定时线程池执行任务。

20190507
Collection
一组"对立"的元素，通常这些元素都服从某种规则
　　1.1) List必须保持元素特定的顺序
　　1.2) Set不能有重复元素
　　1.3) Queue保持一个队列(先进先出)的顺序2) Map
一组成对的"键值对"对象
Collection和Map的区别在于容器中每个位置保存的元素个数:

1) Collection 每个位置只能保存一个元素(对象)2) Map保存的是"键值对"，就像一个小型数据库。我们可以通过"键"找到该键对应的"值"



EventBus 观察者模式
订阅着要执行注册方法
这个方法会递归遍历这个类已经他的父类们所有声明的方法，找到含有Subscribe注解，并且参数只有一个的方法存入到集合里面。

发送消息时
先把消息全部压入数组中，然后while循环判断队列是否为空，否则不断的去准备发送消息。
通过消息对象，去方法集合中，找到方法所在的类，方法名，已及注解需要运行的线程
post就是发送者在什么线程回调就在什么线程
main是主线程
background和aync都是利用线程缓存池
但是background如果是主线程就切换到后台线程中，如果当前不是在主线程就不去切换了。
最后利用反射执行回调函数




